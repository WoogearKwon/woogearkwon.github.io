---
title:  "배워서 남주는 정규표현식(2)"
date:   2022-08-30 12:03:26 +0900
categories: 정규표현식 regex
---

이전글: [배워서 남주는 정규표현식(1)]({% post_url 2020-08-30-regex-1 %})


이 글에서는 바로 정규표현식의 기본 문법격인 메타문자(meta character)에 대해서만 알아보기로 한다.  지난 글에서 일부 메타 문자를 예제로 다루기는 했지만 모두 다룰 수 없어서 이곳에 따로 정리했다. 정규식 연습 및 결과 확인은 [regexr.com](https://regexr.com/6sr67)을 사용하고 있다. 각 카테고리에 해당하는 소제목 중 상당수는 한글로 어떻게 번역되는지를 정확히 알 수 없어서 영어로 표기하였다.

# 1. Character Classes [기호 클래스]
   기호 클래스는 특정 set에서 문자를 찾는다.

| 정규식<br/>(예시)	    | 명칭                         | 매칭 조건                      | 비고                                                       |
|------------------|----------------------------|----------------------------|----------------------------------------------------------|
| [ABC]	           | character set              | [ ] 안의 문자들                 | 예) [a-z], [0-9], [a-c], [+_]                             |
| [^ABC]           | negated set                | [ ]안에 포함되지 않은 모든 문자들       | 예) [^a-c]                                                |
| [A-Z]            | range (범위)                 | 문자 사이에 속하는 모든 문자들          | 예) [a-e] -> a, b, c, d, e                                | 
| .	dot<br/>(마침표)	 | 줄바꿈(line break)을 제외한 모든 문자 |                            |                                                          |
| \w               | word                       | 	알파벳, 숫자, 언더스코어를 포함한 모든 문자 | [A-Za-z0-9_]와 동일, 한글은 포함하지 않음                            |
| \W               | 	not word	                 | \w와 반대                     | 	[^A-Za-z0-9_]와 동일, <br/>è, ë 와같이 머리에 기호를 달고 있는 알파벳이 포함됨 |
| \d               | digit                      | 숫자	[0-9]와 동일               |                                                          |
| \D	              | not digit	                 | \d와 반대                     | [^0-9]와 동일                                               |
| \s               | whitespace                 | 공백                         |                                                          |	 
| \S	              | not whitespace             | 공백이 아닌 모든 조건               |                                                          |

<br/>

# 2. Quantifiers & Alternation [수량자와 교체 구문]
Quantifier(수량자)는 앞의 문자(token)의 개수가 특정 개수와 일치해야함을 가리킨다. Quantifier는 기본적으로 탐욕적(greedy)이기 때문에 가능한 많은 문자를 찾아낸다.
Alternation(교체 구문)은 boolean OR 연산자와 동일하게 동작한다.

| 정규식	 | 명칭	                                                             | 매칭 조건	                                                                           | 비고                             |
|--|-----------------------------------------------------------------|----------------------------------------------------------------------------------|--------------------------------|
| +	 | plus	                                                           | +기호 앞의 조건이 1개 이상 존재	                                                             | 예) b\w+ -> be, bee, beer ..    |
| *	 | start	*기호 앞의 조건이  없거나 1개 이상 존재                                  | 	예) b\w* -> b, be, beer                                                          |
| {3} | 	quantifier                                                     | 	괄호 앞의 조건이 괄호 안 숫자에 해당하는 만큼의 반복이 존재	                                             | 예) ab{3} -> abbb               |
| {min, max} | 	quantifier | 괄호 앞의 조건이 min~max 만큼의 반복이 존재 | 예) ab{1, 2} -> ab, abb |
| {min,}	 | quantifier | 괄호 앞의 조건이 최소 min 만큼의 반복이 존재 | 예) ab{2,} -> abb, abbb   |
| ? | 	optional | ?기호 앞의 조건이 있거나 없음 | 예) colou?r -> color, colour |
| ?	 | lazy quantifier (게으른 수량자) | 수량자는 기본적으로 탐욕적인 반면, 게으른 수량자를 사용하면 가능한 더 적고 짧은 값을 반환한다.| 예) b\w+? -> `be`e, `ba`ck, `ba`c     |
| `|`| 	alternation (교체 구문)	 | 기호 기준 좌우 기준 중 어떤 것이든 존재 | 예) `b(a|e|i)d` -> bad, bed, bid|


<br/>

# 3.Anchors [앵커]
앵커는 문자열 내의 문자가 아닌 위치를 찾는다는 점에서 독특하다.

| 정규식	 | 명칭                | 매칭 조건                                      | 비고       |
|------|-------------------|--------------------------------------------|----------|
| ^    | beginning         | 문자열의 시작 혹은 라인의 시작<br/>이 기호는 문자가 아닌 위치를 매칭함 | 예) ^\w+  |
| $    | end               | 문자열의 끝 혹은 라인의 끝<br/> 이 기호는 문자가 아닌 위치를 매칭함  | 예) \w+$  |
| \b   | word boundary     | 경계에 위치한 문자<br/>문자, 비문자, 문자의 시작과 끝 사이       | 예) \w\b  |
| \B   | not word boundary | 경계가 아닌 모든 위치                               | 	예) \w\B |


<br/>

# 4. Groups & References [그룹과 참조]
   그룹은 연속된 기호가 묶여있는 형태이다. 이미 찾은 캡쳐 그룹은 *역참조를 통해 참조할 수 있다.

*`역참조(backreference)`: 패턴의 일부를 하위 표현식으로 묶으면, 첫 번째로 나타나는 부분 문자열을 찾은 뒤에 역참조를 통해 이후에 나타나는 문자열을 찾을 수 있음

| 정규식(예시)	 | 명칭	                   | 설명	                                                                            | 비고                                              |
|----------|-----------------------|--------------------------------------------------------------------------------|-------------------------------------------------|
| (ABC)    | 	capturing group	     | 괄호 안 조건에 매칭되는 문자열을 그룹으로 묶음<br/>Kotlin에서는 그룹에 걸린 매칭결과를 List<String>으로 접근할 수 있음	 | 예) (ha)+                                        |
| (?:ABC)  | 	non-capturing group	 | 괄호 안 조건에 매칭되는 문자열을 찾지만 그룹에 포함시키지는 않음                                           | 	예) (?:ha)+                                     |
| \1	      | backreference (역참조)   | 	캡쳐 그룹의 결과를 찾음<br/> 예) `\1`은 첫 번째 캡쳐그룹의 결과를 찾는다.	                              | 예) (\w)a\1 -> hah <br/>* 여기서 1번째 캡쳐그룹의 결과는 h이다. |

<br/>

# 5. Lookaround [전후방 탐색]
   Lookaround는 메인 패턴의 전(lookahead)과 후(lookbehind)에 있는 그룹을 매치시키지만 결과에는 포함시키지 않는다. 아쉽게도 우리가 사용중인 regexr.com은 후방탐색은 지원하지 않고 있다. 후방탐색을 연습해보고 싶다면 [regexone.com](regexone.com)을 사용해보길 바란다.

| 정규식(예시)   | 	명칭                  | 	설명	                                              | 비고                   |
|-----------|----------------------|---------------------------------------------------|----------------------|
| (?=ABC)	  | positive lookahead	  | 메인 표현식 뒤의 그룹과 일치하는 조건을 찾지만 그룹의 패턴은 결과에 포함시키지 않음	  | 예) \d(?=px) -> 2px   |
| (?!ABC)	  | negative lookahead	  | 메인 표현식 뒤의 그룹과 않는 조건을 찾지만 그룹의 패턴은 결과에 포함시키지 않음	    | 예) \d(?!px) -> 2pt   |
| (?<=ABC)  | 	positive lookbehind | 	메인 표현식 앞의 그룹과 일치하는 조건을 찾지만 그룹의 패턴은 결과에 포함시키지 않음	 | 예) (?<=\d)\w+ -> 2pt |
| (?<!ABC)	 | negative lookbehind	 | 메인 표현식 앞의 그룹과 일치하는 조건을 찾지만 그룹의 패턴은 결과에 포함시키지 않음   |                      |

<br/>

# 맺음말
위에 나열된 메타문자 외에도 추가적인 것들이 존재하지만, 그 외는 각 언어에 한정된 패턴이거나 기본적인 범위를 벗어난다고 봐도 무방할 것 같다. 위의 기본적인 메타문자들만 잘 숙지해서 조합하면 상당히 많은 패턴을 만들 수 있다.

<br/>

# 참고한 곳 출처
- 메타 문자 참조: [https://regexr.com/](https://regexr.com/)
- 역참조(backreference): [https://blog.hexabrain.net/204](https://blog.hexabrain.net/204)